<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高考导数题合辑</title>
      <link href="/gao-kao-dao-shu-ti-he-ji/"/>
      <url>/gao-kao-dao-shu-ti-he-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有三个小问的导数题，第（3）问需要踩第（2）问的结论继续研究，这是2019、2022、2023告诉我们亘古不变的真理。</p></blockquote><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><img src="/images/2023/5.png" width="40%" height="40%"><p>（1）<br>因为$f(x)=e^xln(1+x)$，<br>所以$f’(x)=e^x[\frac{1}{1+x}+ln(1+x)]$。<br>所以$f(0)=0$，$f’(0)=1$，<br>所以曲线$y=f(x)$在$(0,f(0))$处的切线方程为$y=x$。<br>（2）<br>由题设，$g(x)=e^x[\frac{1}{1+x}+ln(1+x)]$，<br>所以$g’(x)=e^x[\frac{1+2x}{(1+x)^2}+ln(1+x)]$。<br>因为$x&gt;0$，所以$g’(x)&gt;0$，<br>所以函数$g(x)$在$[0,+∞)$上单调递增。<br>（3）<br>不妨假设$t&gt;0$取定，令$h(x)=f(x+t)-f(x)-f(t)$，$x∈[0,+∞)$，<br>则$h’(x)=f’(x+t)-f’(x)$，$x∈[0,+∞)$。<br>由（2）知，$f’(x)$在$[0,+∞)$上单调递增，<br>所以$h’(x)=f’(x+t)-f’(x)&gt;0$，<br>从而$h(x)$在$[0,+∞)$上单调递增。<br>因为$h(0)=-f(0)=0$，<br>所以当$s&gt;0$时，$h(s)&gt;h(0)=0$，即$f(s+t)-f(s)-f(t)&gt;0$，<br>综上，对任意的$s,t∈(0,+∞)$，有$f(s+t)&gt;f(s)+f(t)$。</p><blockquote><p>本题第（1）问是平和的求切线问题。本题第（2）问考察研究函数单调性的通性通法，通过直接观察$g’(x)$的代数特征来判断正负而非继续求导是考生应当具有的能力。本题第（3）问是意料之外的双元变量问题，角度刁钻难度大，因而仍不是后续复习的方向。另外，本题第（3）问的命题背景是凹函数的性质，感兴趣的大学生可以进一步了解。</p></blockquote><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><img src="/images/2023/6.png" width="55%" height="55%"><p>（1）<br>当$a=0$时，$f(x)=\frac{3}{x^2}-\frac{2}{x}$，$f’(x)=-\frac{6}{x^3}+\frac{2}{x^2}$。<br>所以$f(1)=1$，$f’(1)=-4$，<br>所以曲线$y=f(x)$在$(1,f(1))$处的切线方程为$y=-4x+5$。<br>（2）<br>由$f(x)=\frac{3-2x}{x^2+a}$得$f’(x)=\frac{2(x^2-3x-a)}{(x^2+a)^2}$。<br>由题意知$f’(-1)=0$，所以$(-1)^2-3×(-1)+a=0$，解得$a=4$。<br>当$a=4$时，$f(x)=\frac{3-2x}{x^2+4}$，$f’(x)=\frac{2(x+1)(x-4)}{(x^2+4)^2}$。<br>$f’(x)$与$f(x)$的情况如下：</p><table><thead><tr><th>$x$</th><th>$(-∞,-1)$</th><th>$-1$</th><th>$(-1,4)$</th><th>$4$</th><th>$(4,+∞)$</th></tr></thead><tbody><tr><td>$f’(x)$</td><td>$+$</td><td>$0$</td><td>$-$</td><td>$0$</td><td>$+$</td></tr><tr><td>$f(x)$</td><td>$↗$</td><td>$1$</td><td>$↘$</td><td>$-\frac{1}{4}$</td><td>$↗$</td></tr></tbody></table><p>因此$f(x)$的单调递增区间是$(-∞,-1)$和$(4,+∞)$，单调递减区间是$(-1,4)$。<br>所以$f(x)$在区间$(-∞,4)$上的最大值是$f(-1)=1$。<br>又因为当$x∈(4,+∞)$时，$f(x)&lt;0$，所以$f(-1)=1$是$f(x)$的最大值。<br>同理当$x∈(-∞,-1)$时，$f(x)&gt;0$，所以$f(4)=-\frac{1}{4}$是$f(x)$的最小值。</p><blockquote><p>本题的第（1）问是平和的求切线问题。本题第（2）问揭示了研究函数性态问题的一般性方法，属一道经典好题。在第（2）问中，由于导函数值为$0$是函数取得极值的必要而不充分条件，所以需要列表验证$-1$是导函数的变号零点。此外，在研究函数最值时，通过观察原函数的代数特征，判断在特定区间中函数的值域（最常见的是判断正负），是利用导数研究函数问题的高阶核心能力。</p></blockquote><h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><img src="/images/2023/7.png" width="50%" height="50%"><p>（1）<br>因为$f(x)=12-x^2$，<br>所以$f’(x)=-2x$。<br>令$f’(x)=-2$，解得$x=1$。<br>因为$f(1)=11$，<br>所以曲线$y=f(x)$在$(1,f(1))$处的切线方程为$y=-2x+13$。<br>（2）<br>由题设，$t≠0$。<br>当$t&gt;0$时，切线的斜率为$f’(t)=-2t$，切线方程为$y=-2tx+t^2+12$。<br>该切线与$x$轴的交点为$(\frac{t^2+12}{2t},0)$，与$y$轴的交点为$(0,t^2+12)$，<br>所以$S(t)=\frac{1}{2}(\frac{t^2+12}{2t})(t^2+12)=\frac{1}{4}t^3+6t+\frac{36}{t}$。<br>$S’(t)=\frac{3(t^2+12)(t+2)(t-2)}{4t^2}$。<br>$S’(t)$与$S(t)$的情况如下：</p><table><thead><tr><th>$t$</th><th>$(0,2)$</th><th>$2$</th><th>$(2,+∞)$</th></tr></thead><tbody><tr><td>$S’(t)$</td><td>$-$</td><td>$0$</td><td>$+$</td></tr><tr><td>$S(t)$</td><td>$↘$</td><td>$32$</td><td>$↗$</td></tr></tbody></table><p>当$t=2$时，$S(t)$取得最小值$32$。<br>当$t&lt;0$时，因为$f(x)$是偶函数，由对称性知当$t=-2$时，$S(t)$取得最小值$32$。<br>综上所述，$S(t)$的最小值为$32$，此时$t=±2$。</p><blockquote><p>本题的亮点是基于非常平易近人的二次函数考察使用导数工具研究问题的过程，让人眼前一亮。第（1）问沿袭2019年给斜率确定切点求切线的设问方式，难度平和。第（2）问首先要确定$f(x)$是偶函数，只讨论$t&gt;0$，减轻负担。然后根据几何元素确定$S(t)$的表达式，并用导数工具确定$S(t)$的最小值，明确“导数是研究函数的工具”这一主旋律。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 高中数学题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习，你在干嘛？</title>
      <link href="/shen-du-xue-xi-ni-zai-gan-ma/"/>
      <url>/shen-du-xue-xi-ni-zai-gan-ma/</url>
      
        <content type="html"><![CDATA[<p>FROM. 李宏毅老师的网上教程。</p><h1 id="一、人生意义：找函数罢了"><a href="#一、人生意义：找函数罢了" class="headerlink" title="一、人生意义：找函数罢了"></a>一、人生意义：找函数罢了</h1><p>深度学习找一个函数$y=f(x)$。其中$x$和$y$可以是数值、序列、自然语言、图片视频音频等等。<br>深度学习用来回归（给一个$x$得一个$y$）、分类、创作……</p><h1 id="二、干活的准则：损失函数"><a href="#二、干活的准则：损失函数" class="headerlink" title="二、干活的准则：损失函数"></a>二、干活的准则：损失函数</h1><p>MAE：$e=|y-\widehat{y}|$；MSE：$e=(y-\widehat{y})^2$。<br>损失Loss为$L=\frac{1}{n}\sum_{n}e_n$。</p><h1 id="三、谁来指引我干活：梯度下降"><a href="#三、谁来指引我干活：梯度下降" class="headerlink" title="三、谁来指引我干活：梯度下降"></a>三、谁来指引我干活：梯度下降</h1><p>函数在某点的梯度是一个向量，它的方向与取得最大方向导数的方向一致，它的模为方向导数的最大值。<br>所以沿梯度方向，损失函数Loss咵咵咵降得最快，能尽早降到导数值是0的点，也就找到了损失函数的极小值点。<br>每次算完梯度$\nabla$后，$w(n+1)=w(n)-\eta\frac{dLoss}{dw(n)}$，超参$\eta$是学习率。<br>$\theta(n+1)=argmin_{\theta}(L)$。</p><h1 id="四、计算机怎么算梯度：反向传播"><a href="#四、计算机怎么算梯度：反向传播" class="headerlink" title="四、计算机怎么算梯度：反向传播"></a>四、计算机怎么算梯度：反向传播</h1><p>网络从前往后搭，梯度从后往前算。<br>（具体而言就是算链式法则求导，理解起来不难，但不想写了，写到现在都0:25了，开摆！）</p><h1 id="五、刻画函数：激活函数"><a href="#五、刻画函数：激活函数" class="headerlink" title="五、刻画函数：激活函数"></a>五、刻画函数：激活函数</h1><p>Sigmoid：$y=c\frac{1}{1+e^{-(b+wx)}}$，用一些Sigmoid的线性组合可以组成各式各样的函数；<br>ReLU：$y=c max(0,b+wx)$，用一些ReLU的线性组合可以组成各式各样的函数。</p><h1 id="六、神经元在工作"><a href="#六、神经元在工作" class="headerlink" title="六、神经元在工作"></a>六、神经元在工作</h1><p>$y=b+\sum_{i}c_i sigmoid(b_i+\sum_{j}w_{ij}x_j)$，<br>即，$y=b_{0}+C^T\sigma(b+wx)$。</p><h1 id="七、内存装不下"><a href="#七、内存装不下" class="headerlink" title="七、内存装不下"></a>七、内存装不下</h1><p>batch：每次读入一个batch，然后根据这一个batch的数据往梯度下降的方向来调整网络中的各种参数，使得损失函数的值尽可能小。<br>太小的batch会导致计算时间过长，太大的batch会导致准确率不高。<br>epoch：跑完所有batch是一轮epoch。</p><h1 id="八、搭建深度学习神经网络"><a href="#八、搭建深度学习神经网络" class="headerlink" title="八、搭建深度学习神经网络"></a>八、搭建深度学习神经网络</h1><p>堆更多的隐藏层，小心过拟合哈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机与安全理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装BCC指南</title>
      <link href="/ubuntu-an-zhuang-bcc-zhi-nan/"/>
      <url>/ubuntu-an-zhuang-bcc-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>eBPF（Extended Berkeley Packet Filter，扩展伯克利数据包过滤器），是一个在Linux操作系统中运行沙盒程序的工具，从而让我们可以在Linux操作系统中 <del>为所欲为</del> 进行网络数据包过滤、<strong>安全监控与分析</strong>等。<br>eBPF本身原理比较复杂 <del>我还没学会</del>，详见官网：<a href="http://www.ebpf.io/">http://www.ebpf.io/</a><br>eBPF会将C语言源代码编译成eBPF字节码，然后钩到Linux操作系统上等待被触发。<del>这辈子也别想让程序设计基础63分的我写C</del> 。为了能够使用Python等更加高级的语言使用eBPF的功能，开发人员设计了一些eBPF工具链以解放程序员，例如<strong>BCC</strong>、Cilium、Bpftrace等。<br>BCC（BPF Compiler Collection）是一个基于eBPF的工具包，该工具包提供了一些库，使得我们可以利用Python写eBPF程序，还提供了一些命令行和<strong>示例</strong> <del>感谢这些示例，我连Python都不用写啦！</del>。<br><strong>本文介绍如何在Ubuntu</strong>（最常见的一个Linux操作系统）<strong>中安装BCC。</strong> 读至文章末尾，相信你一定可以运行BCC示例。</p><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>你需要确保</p><ul><li>在VmWare中安装好Ubuntu（版本号：22.04 LTS）虚拟机；</li><li>保证虚拟机网络正常；（如果不正常可以重启一下虚拟机碰碰运气）</li><li>安装VMware Tools；（这个不是必须的，但不弄好多别扭啊）</li><li>换源！<a href="https://blog.csdn.net/qq_45878098/article/details/126037838">ubuntu换源_须臾所学的博客-CSDN博客</a></li><li>记得随时拍快照。</li></ul><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>下面的命令行均在主目录的终端执行。<br>先更新升级。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo apt-get updatesudo apt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将Python的默认版本改为python3。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo apt-get install python-is-python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装如下依赖。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo apt-get <span class="token operator">-</span>y install bisonsudo apt-get <span class="token operator">-</span>y install build-essentialsudo apt-get <span class="token operator">-</span>y install cmakesudo apt-get <span class="token operator">-</span>y install flexsudo apt-get <span class="token operator">-</span>y install gitsudo apt-get <span class="token operator">-</span>y install libedit-devsudo apt-get <span class="token operator">-</span>y install zlib1g-devsudo apt-get <span class="token operator">-</span>y install libelf-devsudo apt-get <span class="token operator">-</span>y install python3-distutilssudo apt-get install llvm-12sudo apt-get install libclang-12-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>在虚拟机里进入网页<a href="https://github.com/iovisor/bcc/releases">Releases · iovisor/bcc (github.com)</a>，下载安装包，把安装包解压放在主目录。<br>此时你的主目录里面有个bcc-src-with-submodule的文件夹，该文件夹内部有bcc文件夹，bcc文件夹内部有很多文件夹和文件。<br>注意：**此处不能在物理机下载安装包再用VMware Tools把安装包复制到虚拟机内部，这样会报莫名其妙的错误！<br>下面的命令行均在bcc-src-with-submodule的终端执行。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">mkdir bcc/buildcd bcc/buildcmake <span class="token punctuation">.</span><span class="token punctuation">.</span>makesudo make installcmake <span class="token operator">-</span>DPYTHON_CMD=python3 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">pushd</span> src/python/makesudo make install<span class="token function">popd</span>export PYTHONPATH=$<span class="token punctuation">(</span>dirname `find <span class="token operator">/</span>usr/lib <span class="token operator">-</span>name bcc`<span class="token punctuation">)</span>:<span class="token variable">$PYTHONPATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><p>在bcc-src-with-submodule的终端执行下面的命令行。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">cd <span class="token operator">/</span>usr/share/bcc/tools<span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你应当看到下图这些BCC示例。<br><img src="/images/2023/3.png" width="50%" height="50%"><br>这些示例均可以直接使用。以cachestat为例，命令行如下。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo <span class="token punctuation">.</span><span class="token operator">/</span>cachestat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果可以看到终端中正在生成如下的表格，则表明安装成功！<br><img src="/images/2023/4.png" width="30%" height="30%"></p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>本文参考了：<a href="https://blog.csdn.net/weixin_43793731/article/details/128364192">Ubuntu 18.04 LTS上编译安装BCC_银杏丷的博客-CSDN博客</a>，对此表示感谢！<br>如有问题可在评论区提问。<del>如果我刚好能解答的话我就解答了</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机与安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【算法】图的邻接矩阵：-K-顶点"><a href="#【算法】图的邻接矩阵：-K-顶点" class="headerlink" title="【算法】图的邻接矩阵：$K$顶点"></a>【算法】图的邻接矩阵：$K$顶点</h1><p>（2023年408统考第41题，13分）<br>已知有向图$G$采用邻接矩阵存储，定义如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct{                                      //图的定义int numVertices, numEdges;                       //图中实际的顶点数和边数char VerticesList[MAXV];                         //顶点表，MAXV为已定义常数int Edge[MAXV][MAXV];                            //边表}MGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将图中出度大于入度的顶点称为$K$顶点。例如，下图中结点$a$和结点$b$均为$K$顶点。<br><img src="/images/2023/2.png" width="15%" height="15%"><br>请设计算法<code>int printVertices(MGraph G)</code>，对任意给定的非空有向图$G$，输出$G$中所有$K$顶点，并返回$K$顶点的个数。<br>（1）给出算法的基本思想；（2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。</p><hr><blockquote><p>邻接矩阵中第$i$行之和即为第$i$个顶点的出度，第$i$列之和即为第$i$个顶点的入度。因此，只要分别按行按列遍历图$G$的邻接矩阵，即可求出每个顶点的入度和出度。如果一个顶点的出度大于入度，则将该$K$顶点输出，计数器加一。</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">int printVertices(MGraph G){                      //打印图G的所有K顶点并计数int i, j;int inDegree, outDegree;int count = 0;for(i=0;i&lt;G.numVertices;++i){                 //遍历图的顶点inDegree = 0;                             //初始化顶点的入度outDegree = 0;                            //初始化顶点的出度for(j=0;j&lt;G.numVertices;++j){if(G.Edge[i][j]==1) outDegree++;      //有结点i到结点j的边，出度加一if(G.Edge[j][i]==1) inDegree++;       //有结点j到结点i的边，入度加一}if(outDegree&gt;inDegree){                   //出度大于入度的顶点是K顶点printf("%s是K顶点\n",G.VerticeList[i]);                                      //输出K顶点count++;                              //计数器的值加一}                    }return count;}                                                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li>时间复杂度O($n^2$)，空间复杂度O(1)；</li><li>vertex(pl. vertices) n.顶点、头顶、天顶；</li><li>以上代码来源于ChatGPT，有删改。</li></ol></blockquote><h1 id="【算法】外部排序：置换-选择算法"><a href="#【算法】外部排序：置换-选择算法" class="headerlink" title="【算法】外部排序：置换-选择算法"></a>【算法】外部排序：置换-选择算法</h1><p>（2023年408统考第42题，10分）<br>对含有$n$（$n&gt;0$）个记录的文件进行外部排序，采用置换-选择算法生成初始归并段时需要使用一个工作区，工作区中能保存$m$个记录，请回答下列问题：<br>（1）若$n=19$，文件记录的关键字是：51、94、37、92、14、63、15、99、48、56、23、60、31、17、43、8、90、166、100。当$m=4$时，可以生成几个初始归并段，每个初始归并段中的内容是什么？<br>（2）对于任意的$n\gg m&gt;0$，求生成的第一个归并段的长度的最大值和最小值。</p><hr><blockquote><p>前情提要：为什么我们需要置换-选择算法？</p><p>外部排序的时间开销主要花费在磁盘块的读写过程中，所以减少归并趟数$S$，就能减少读写磁盘的次数，从而提高外部排序的速度。可以求得$S=\lceil \log_{k}r \rceil$，其中$k$是归并路数，$r$是初始归并段的长度。因此，通过败者树可以增大归并路数$k$，通过置换选择排序生成更长的初始归并段可以减小$r$，在初始归并段长度不等的情况下使用最佳归并树，均可以减少$S$的值。</p><p>而$r=\lceil \frac{n}{l} \rceil$，其中$n$是记录数，$l$是每个归并段的长度。$n$由文件的客观属性决定，无法改变；而置换选择算法增大了$l$，相较于不使用置换-选择排序算法，其$l$平均增加了一倍。因此，我们需要置换-选择算法提高外部排序的速度。</p></blockquote><blockquote><p>置换-选择算法的步骤如下：</p><ol><li>从文件中（从前往后地）输入记录到内存工作区中，直至内存工作区满或者文件中不再含有记录；</li><li>记MINIMAX为工作区中的最小元素；</li><li>将MINIMAX输出；</li><li>若仍有记录未输入进工作区，则从文件中输入一个记录进入内存工作区中；</li><li>从内存工作区中找出<strong>不小于MINIMAX的最小元素</strong>，输出该元素并把该元素记为MINIMAX；</li><li>重复第3步至第5步，直至内存工作区中所有元素均小于MINIMAX。一个归并段生成，MINIMAX重置。</li><li>重复第2步至第6步，直至内存工作区中没有元素，置换选择排序算法结束。</li></ol></blockquote><p>以第（1）问作为例子来熟悉置换-选择排序。</p><ul><li><p>读入前4条记录，此时工作区中的内容为：51、94、37、92，取MINIMAX=37，把37输出到第一个归并段；</p></li><li><p>读入14，此时工作区中的内容为：51、94、14、92，<strong>不小于MINIMAX=37的最小元素是51</strong>，取MINIMAX=51，把51输出到第一个归并段；</p></li><li><p>读入63，此时工作区中的内容为：63、94、14、92，<strong>不小于MINIMAX=51的最小元素是63</strong>，取MINIMAX=63，把63输出到第一个归并段；</p></li><li><p>读入15，此时工作区中的内容为：15、94、14、92，<strong>不小于MINIMAX=63的最小元素是92</strong>，取MINIMAX=92，把92输出到第一个归并段；</p></li><li><p>读入99，此时工作区中的内容为：15、94、14、99，<strong>不小于MINIMAX=92的最小元素是94</strong>，取MINIMAX=94，把94输出到第一个归并段；</p></li><li><p>读入48，此时工作区中的内容为：15、48、14、99，<strong>不小于MINIMAX=94的最小元素是99</strong>，取MINIMAX=99，把99输出到第一个归并段；</p></li><li><p>读入56，此时工作区中的内容为：15、48、14、56，工作区中没有不小于MINIMAX=99的元素。第一个归并段完成，其内容为：37、51、63、92、94、99。</p></li><li><p>此时工作区中的内容为：15、48、14、56，取MINIMAX=14，把14输出到第二个归并段；</p></li><li><p>读入23，此时工作区中的内容为：15、48、23、56，<strong>不小于MINIMAX=14的最小元素是15</strong>，取MINIMAX=15，把15输出到第二个归并段；</p></li><li><p>读入60，此时工作区中的内容为：60、48、23、56，<strong>不小于MINIMAX=15的最小元素是23</strong>，取MINIMAX=23，把23输出到第二个归并段；</p></li><li><p>读入31，此时工作区中的内容为：60、48、31、56，<strong>不小于MINIMAX=23的最小元素是31</strong>，取MINIMAX=31，把31输出到第二个归并段；</p></li><li><p>读入17，此时工作区中的内容为：60、48、17、56，<strong>不小于MINIMAX=31的最小元素是48</strong>，取MINIMAX=48，把48输出到第二个归并段；</p></li><li><p>读入43，此时工作区中的内容为：60、43、17、56，<strong>不小于MINIMAX=48的最小元素是56</strong>，取MINIMAX=56，把56输出到第二个归并段；</p></li><li><p>读入8，此时工作区中的内容为：60、43、17、8，<strong>不小于MINIMAX=56的最小元素是60</strong>，取MINIMAX=60，把60输出到第二个归并段；</p></li><li><p>读入90，此时工作区中的内容为：90、43、17、8，<strong>不小于MINIMAX=60的最小元素是90</strong>，取MINIMAX=90，把90输出到第二个归并段；</p></li><li><p>读入166，此时工作区中的内容为：166、43、17、8，<strong>不小于MINIMAX=90的最小元素是166</strong>，取MINIMAX=166，把166输出到第二个归并段；</p></li><li><p>读入100，此时工作区中的内容为：100、43、17、8，工作区中没有不小于MINIMAX=166的元素。第二个归并段完成，其内容为：14、15、23、31、48、56、60、90、166。</p></li><li><p>此时工作区中的内容为：100、43、17、8，所有数据均已进入工作区。取MINIMAX=8，把8输出到第三个归并段；</p></li><li><p>此时工作区中的内容为：100、43、17、$\varnothing$，取MINIMAX=17，把17输出到第三个归并段；</p></li><li><p>此时工作区中的内容为：100、43、$\varnothing$、$\varnothing$，取MINIMAX=43，把43输出到第三个归并段；</p></li><li><p>此时工作区中的内容为：100、$\varnothing$、$\varnothing$、$\varnothing$，取MINIMAX=100，把100输出到第三个归并段；</p></li><li><p>此时工作区空空如也：$\varnothing$、$\varnothing$、$\varnothing$、$\varnothing$，第三个归并段完成，其内容为：8、17、43、100，置换-选择算法也结束了。</p></li></ul><p>故第（1）问的答案为：<strong>生成3个初始归并段，第一个初始归并段为：37、51、63、92、94、99；第二个初始归并段为：14、15、23、31、48、56、60、90、166；第三个初始归并段为：8、17、43、100。</strong></p><p>对于第（2）问，考虑极端情况。</p><p>若原来的文件已经正序，即$x_1 \leq x_2 \leq \cdots \leq x_n$，则将$x_i$作为MINIMAX时，后面的元素均不小于MINIMAX，则后面的元素均可以按照从小到大的顺序排在$x_i$的后面，此时所有元素都在第一个归并段中，此时第一个归并段的长度为$n$，显然这也是第一个归并段的长度的最大值。</p><p>若原来的文件中$x_1$、$x_2$、$\cdots$、$x_m$是最大的$m$个元素，则将这$m$个元素中的任意一个作为MINIMAX时，后面的文件记录在归并段中均无法位于前面$m$个元素的后面，也就无法与前面$m$个元素位于同一个归并段中，此时第一个归并段的长度为$m$，显然这也是第一个归并段的长度的最小值。</p><p>故第（2）问的答案为：<strong>生成的第一个归并段的长度的最大值为</strong>$n$，<strong>最小值为</strong>$m$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机考试题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好呀</title>
      <link href="/ni-hao-ya/"/>
      <url>/ni-hao-ya/</url>
      
        <content type="html"><![CDATA[<p>Halo，这里是Cardioid-line的Blog。</p><p>Cardioid-line是我好不容易想到的名字。</p><p>天天开心 ^_^</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
