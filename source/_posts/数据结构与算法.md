---
title: 数据结构与算法
date: 2023-02-15 22:00:00
author: Cardioid
top: false
hide: false
cover: false
toc: false
mathjax: true
summary: 【数据结构与算法】习题选编
categories: 
tags: 计算机与安全理论
---

# 【算法】图的邻接矩阵：$K$顶点
（2023年408统考第41题，13分）
已知有向图$G$采用邻接矩阵存储，定义如下：
``` C
typedef struct{                                      //图的定义
	int numVertices, numEdges;                       //图中实际的顶点数和边数
	char VerticesList[MAXV];                         //顶点表，MAXV为已定义常数
	int Edge[MAXV][MAXV];                            //边表
}MGraph;
```
将图中出度大于入度的顶点称为$K$顶点。例如，下图中结点$a$和结点$b$均为$K$顶点。
<img src="/images/2023/2.png" width="15%" height="15%"/>
请设计算法`int printVertices(MGraph G)`，对任意给定的非空有向图$G$，输出$G$中所有$K$顶点，并返回$K$顶点的个数。
（1）给出算法的基本思想；（2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。
___
> 邻接矩阵中第$i$行之和即为第$i$个顶点的出度，第$i$列之和即为第$i$个顶点的入度。因此，只要分别按行按列遍历图$G$的邻接矩阵，即可求出每个顶点的入度和出度。如果一个顶点的出度大于入度，则将该$K$顶点输出，计数器加一。

```C
int printVertices(MGraph G){                      //打印图G的所有K顶点并计数
	int i, j;
	int inDegree, outDegree;
	int count = 0;
	for(i=0;i<G.numVertices;++i){                 //遍历图的顶点
		inDegree = 0;                             //初始化顶点的入度
		outDegree = 0;                            //初始化顶点的出度
		for(j=0;j<G.numVertices;++j){
			if(G.Edge[i][j]==1) outDegree++;      //有结点i到结点j的边，出度加一
			if(G.Edge[j][i]==1) inDegree++;       //有结点j到结点i的边，入度加一
		}
		if(outDegree>inDegree){                   //出度大于入度的顶点是K顶点
			printf("%s是K顶点\n",G.VerticeList[i]);
			                                      //输出K顶点
			count++;                              //计数器的值加一
		}                    
	}
	return count;
}                                                 
```
>1. 时间复杂度O($n^2$)，空间复杂度O(1)；
>2. vertex(pl. vertices) n.顶点、头顶、天顶；
>3. 以上代码来源于ChatGPT，有删改。